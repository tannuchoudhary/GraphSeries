# BFS - Breadth First Search

BFS is a traversal technique, which is recquired to solve any kind of problem, like in array there is a traversal technique, similarly in graph BFS and DFS are the traversal techniques.

* BFS is a traversal technique in which first we traverse all the adjacent nodes.

* Let us consider a graph here 

  ![Screenshot from 2021-08-28 10-58-48](https://user-images.githubusercontent.com/42698268/131207420-d3a2dc61-ea41-4102-8e42-a4c1e0048a1f.png)

* Now we can see that there are two components of the graph, now we'll traverse all the adjacent nodes in the first graph then the second graph like this:

 ![Screenshot from 2021-08-28 11-02-25](https://user-images.githubusercontent.com/42698268/131207493-d7104c03-36af-4284-98ba-c50683cba8c3.png)

## Steps:
* At first you have to take a visited array of size equal to total no of nodes if graph is 0 based indexing, and size+1 if there is 1 based indexing and mark all of the element as unvisited i.e 0 initially, here we have taken 1 based indexing, so vis[size+1] assigned with 0.
* Now run a for loop for all the nodes, so that none of the components get missed.

so the general driver code would be 
```cpp
    //loop to cover all components
    for(int i=1 to n){
        //if the node is not visited
        if(!vis[i])
            //call bfs starting from that node
            bfs(i);
    }
````
* Now how would you implement BFS, first we have to take a queue(works in FIFO order)
* Now push the first node taken in the queue and mark it visited (this is the initial step)

![Screenshot from 2021-08-28 11-19-29](https://user-images.githubusercontent.com/42698268/131207854-19df905c-0c11-4e02-a6f7-c5a9d003ac25.png)

* Now we will iterate through the queue until it will not become empty.
* Take out the topmost element out of the queue and delete it from the queue

![Screenshot from 2021-08-28 11-19-39](https://user-images.githubusercontent.com/42698268/131207866-ff7c5037-9b2f-4275-851f-ce97cd4bfa35.png)

* Now whenever you take the element out, it will be stored in the answer i.e BFS 
* Now we'll push all the adjacent node of that node into the queue

![Screenshot from 2021-08-28 11-19-53](https://user-images.githubusercontent.com/42698268/131207873-040b9dc4-19ca-4332-95e9-ff26c4369457.png)

![Screenshot from 2021-08-28 11-20-04](https://user-images.githubusercontent.com/42698268/131207883-7b30014f-39da-4203-be5e-7cccd0d043b4.png)


* Remmeber that whenever you'll add anything in the queue, mark it as visited.
* Now repeat the same process until queue will become empty, i.e 
        * push all the adjacent nodes in the queue
        * Mark them as visited while pushing
        * Take the top element from the queue and delete it from the queue
        * Insert it in answer BFS as right now you are traversing it
        * Traverse for all of its unvisited nodes and insert them in queue
        * And if your graph has more than 1 components then again this process will happen with the help of for loop.

## Time complexity and space complexity

### Time complexity
T.C would be ```O(N+E)``` where N is the time taken for visiting N nodes and E is for travelling through adjacent nodes overall.

### Space Complexity
S.C would be ```O(N+E) + O(N) + O(N)``` where, O(N+E) for adjacency list, again O(N) for visited array and alst O(N) for storing the answer, i.e, the BFS array.
```cpp
#include<bits/stdc++.h>
using namespace std;

void bfsHelper(int src, vector<int> &vis, vector<int> &bfs, vector<int> adj[]){
        queue<int> q;
        q.push(src);
        vis[src] = 1;
        while(!q.empty()){
            int node = q.front();
            q.pop();
            bfs.push_back(node);
            for(auto it : adj[node]){
                if(!vis[it]){
                    q.push(it);
                    vis[it] = 1;
                }
            }
        }
    }

vector<int> findBFS(int v, vector<int> adj[]){
    vector<int> vis(v, 0);
    vector<int> bfs;
    for(int i=0; i<v; i++){
        if(!vis[i]){
            bfsHelper(i, vis, bfs, adj);
        }
    }
    
    return bfs;
}
int main(){
    int n, m;
    cin>>n>>m;
    
    vector<int> adj[n];
    for(int i=0; i<m; i++){
        int u, v;
        cin>>u>>v;
        
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    vector<int> ans = findBFS(n, adj);
    for(int i=0; i<n; i++){
        cout<<ans[i]<<" ";
    }
    return 0;
}
```
